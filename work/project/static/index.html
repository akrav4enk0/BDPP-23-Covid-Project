<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title></title>
</head>
<body>
    
<style> /* set the CSS */

body { font: 12px Arial;}

svg {
    display: block;
}

path { 
    stroke-width: 2;
    fill: none;
}

.axis path,
.axis line {
    fill: none;
    stroke: grey;
    stroke-width: 1;
    shape-rendering: crispEdges;
}

.fade-in {

    position: sticky;
    top: 0;
    height: 1px; /* adjust as needed */
    background: linear-gradient(to top, rgba(255,255,255,0), rgba(255,255,255,1));
    transform: scaleY( 20 ) translateY( -5% );
    /*transform: translateY( 100% );*/
}

.fade-out {
    height: 1px; /* adjust as needed */
    background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,1));
    transform: translateY( -1000% ) scaleY( 20 );
}

.logline::before {

    content: "log: ";
}

.logline {

    font-family: monospace;
}

</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js" integrity="sha512-q/dWJ3kcmjBLU4Qc47E4A9kTB4m3wuTY7vkFJDTZKjTs8jhyGQnaUrxa0Ytd0ssMZhbNua9hE+E7Qv1j+DyZwA==" crossorigin="anonymous"></script>

<script type="text/javascript" charset="utf-8">
    socket = io();

    socket.on( "log", ( ...args ) => {

        console.log( ...args )
        logline.html( args.join( ", " ));
    });

</script>

<!-- load the d3.js library -->    
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/6.7.0/d3.min.js"></script>

<script src="./graph.js"></script>

<script type="text/javascript">

    const graphs = [ ];    

    // Your data
    let countries = [ ];

    socket.emit( "get_countries", callback = c => {

        countries = c;
        update_countries( );
    });

    let columns = [ ];

    socket.emit( "get_columns", callback = c => {

        columns = c;
        update_columns( );
    });
    
    let country = null;

    function update_columns( ) {

        columns.forEach( col => {

            graphs.push( graph( col.name, { ...col, data_changed_callback }));
        });
    }

    let version = 0;
    let timeout = null;
    let locked = false;

    function do_prediction( ) {

        if( locked ) {

            console.error( "triggered prediction multiple times" );
            return;
        }

        locked = true;

        timeout = null;
        console.log( "do_prediction" );

        /*
        TODO: here we take the original data for outcomes. in theory, they should be modifiable too and the ternary
        would not be required. for now, this is more stable for subsequent predictions
        */

        const all_data = Object.fromEntries( graphs.map( g => [ 
            
            g.get_column( ), 
            g.is_measure( ) ? g.data_csv( ) : g.orgdata_csv( )
        ]));

        const version_old = version;
        console.log( country );

        const args = [ all_data, country ];
        socket.emit( "predict", args, callback = ([ predicted, pred_start_index ]) => { 

            graphs.forEach( graph => {

                if( ! graph.is_measure( )) {

                    graph.set_data_from_csv( predicted );
                    graph.set_pred_start_index( pred_start_index ?? null )
                }
            });


            //if the data was changed in the meantime, we must predict again right away
            if( version != version_old ) setTimeout( do_prediction, 0 );
            locked = false;
        });    
    }

    function data_changed_callback( from_column ) {

        console.log( "data changed", from_column );
        version += 1;
        if( timeout ) clearTimeout( timeout )
        timeout = setTimeout( do_prediction, 500 );
    }

    // Select the container where you want to add the dropdown
    let select = d3.select("body")  // change "body" to your container's ID or class
      .append("select")
      .attr("class", "select")      // add any classes you need
      .on("change", update_select);

    const logline = d3.select( "body" ).append( "span" ).attr( "class", "logline" );

    d3.select( "body" ).append( "div" ).attr( "class" , "tables" );

    function update_countries( ) {

        // Add options to the dropdown
        select.selectAll("option")
          .data(countries)                // bind your data
          .join( "option" )
          .text(function (d) { return d; });  // set the text of each option to the data value

        update_select( );
    }

    update_countries( );

    // Function to run when an option is selected
    function update_select( ) {

        country = d3.select("body").select("select").property("value");
        // Do something with the selected option
        graphs.forEach( g => g.set_country( country ));
    }

    const outcomes = d3.select( ".tables" ).append( "table" ).attr( "class", "outcomes" );
    const measures = d3.select( ".tables" ).append( "table" ).attr( "class", "measures" );

    measures.append( "div" ).attr( "class" , "fade-in" );    
    
    
    measures
        .style( "display", "block" )
        .style( "position", "relative" )
        .style( "overflow-y", "auto" )
        .style( "height", "250px" )
        .style( "width", "900px" )
        .style( "resize", "vertical" )
        .style( "background", "rgba(240, 248, 255, 0.53)" )
        .style( "padding-top", "10px" )

    d3.select( ".tables" ).append( "div" ).attr( "class" , "fade-out" ); 

    d3.select( "body" ).append( "div" ).attr( "class" , "date" );

</script>
</body>
</html>