"""
warning: autogenerated by writefile2. do not edit!
"""


# do not import with 'require'
import inspect
from signature_match_args import signature_match_args
import functools

def validate_arguments( arg_dict, type_dict ):
    
    for name, annotation in type_dict.items( ):
            
        check_annotation( f"Parameter '{ name }'", annotation, arg_dict[ name ])
    
def check_type( expected_type, given_type ):

    expected_type = type( None ) if expected_type is None else expected_type
    # allow == or as-pickled equality
    return expected_type == given_type or print_types( expected_type ) == print_types( given_type )

def check_types( expected_types, given_type ):

    return any([ check_type( t, given_type ) for t in expected_types ])

def fullname( t ):

    name = t.__qualname__ if hasattr( t, "__qualname__" ) else str( t )
    module = t.__module__ if hasattr( t, "__module__" ) else "builtins"
    return name if module == "builtins" else f"{ module }.{ name }"

def print_types( * types ):

    return " or ".join([ f"'{ fullname( t )}'" for t in types ])

def check_annotation( name, annotation, given_value ):

    given_type = type( given_value )
    if not annotation == inspect._empty:

        expected_types = annotation if type( annotation ) == list else [ annotation ]
        if not check_types( expected_types, given_type ):

            raise Exception( f"{ name }: expected { print_types( * expected_types )}, but got { print_types( given_type )}" )

def typed( f ):
    
    @functools.wraps( f )
    def wrapper( * args, ** kwargs ):
        
        arg_dict = signature_match_args( f, args, kwargs )
        sig = inspect.signature( f )
        type_dict = { param.name: param.annotation for param in sig.parameters.values( )}            
        validate_arguments( arg_dict, type_dict )
        result = f( * args, ** kwargs )
        check_annotation( "Return value", sig.return_annotation, result )
        return result
    
    return wrapper
